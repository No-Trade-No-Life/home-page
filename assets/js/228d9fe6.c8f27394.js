"use strict";(self.webpackChunk_yuants_docs=self.webpackChunk_yuants_docs||[]).push([[8528],{4842:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>t,metadata:()=>o,toc:()=>a});var r=n(9541),i=n(4317);const t={sidebar_position:3},l="Message Mode Layer",o={id:"protocol/message-pattern-layer",title:"Message Mode Layer",description:"Overall, we want Terminals to interact in an orderly and polite manner, so when dividing responsibilities, the goal is to minimize the total communication cost within the Host.",source:"@site/docs/protocol/message-pattern-layer.md",sourceDirName:"protocol",slug:"/protocol/message-pattern-layer",permalink:"/docs/protocol/message-pattern-layer",draft:!1,unlisted:!1,editUrl:"https://github.com/No-Trade-No-Life/Yuan/tree/main/ui/docs/docs/protocol/message-pattern-layer.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Network Layer",permalink:"/docs/protocol/network-layer"},next:{title:"Reference",permalink:"/docs/category/reference"}},c={},a=[{value:"Client/Server Mode",id:"clientserver-mode",level:2},{value:"Publish/Subscribe Mode",id:"publishsubscribe-mode",level:2}];function h(e){const s={code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h1,{id:"message-mode-layer",children:"Message Mode Layer"}),"\n",(0,r.jsxs)(s.p,{children:["Overall, we want Terminals to interact in an orderly and polite manner, so when dividing responsibilities, the goal is to ",(0,r.jsx)(s.strong,{children:"minimize the total communication cost within the Host"}),"."]}),"\n",(0,r.jsx)(s.p,{children:"There are two types of message modes: Client/Server and Publisher/Subscriber."}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"Client/Server mode: The client sends a request to the server, and the server sends a response to the client."}),"\n",(0,r.jsx)(s.li,{children:"Publish/Subscribe mode: The publisher pushes messages to subscribers."}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"clientserver-mode",children:"Client/Server Mode"}),"\n",(0,r.jsx)(s.p,{children:"We use this mode to implement request/response services."}),"\n",(0,r.jsx)(s.p,{children:"The client sends a request to the server, and the server sends a response to the client.\nThe client and server are two Terminals within the same Host.\nRequests and responses are Terminal messages."}),"\n",(0,r.jsx)(s.p,{children:"Services are identified by method names."}),"\n",(0,r.jsx)(s.p,{children:"The core process is:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"Define a method to identify the format and behavior of the request and response."}),"\n",(0,r.jsx)(s.li,{children:"The server should declare in its Terminal information that it provides the service."}),"\n",(0,r.jsx)(s.li,{children:"The client should discover the server and send a request to the server."}),"\n",(0,r.jsx)(s.li,{children:"The server should process the request and send a response to the client."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"More details:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"The server can send multiple messages before sending a response."}),"\n",(0,r.jsxs)(s.li,{children:["The session is the process from request to response, identified by the ",(0,r.jsx)(s.code,{children:"trace_id"})," field in the message."]}),"\n",(0,r.jsx)(s.li,{children:"The server should declare the methods it supports. The discriminator is the method name and JSON Schema."}),"\n",(0,r.jsx)(s.li,{children:"The client should check if the server supports the method and validate the request through JSON Schema before sending the request."}),"\n",(0,r.jsx)(s.li,{children:"If there are multiple valid candidate servers, the client should choose one server to send the request. It is recommended to use a load balancing algorithm to select the server."}),"\n",(0,r.jsx)(s.li,{children:"The server should send the first message within 30 seconds after receiving the request. If the server does not send a response within 30 seconds, the client should throw a timeout error."}),"\n",(0,r.jsx)(s.li,{children:"The server should not continue to send messages to the client after sending a response. If there are any, the client should ignore them."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"How to use this mode:"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Server-side"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"terminal.provideService(\n  'SubmitOrder',\n  {\n    type: 'object',\n    properties: {\n      account_id: { const: 'MyAccountId' },\n    },\n  },\n  (msg) => {\n    // Return an RxJS Observable / Promise / AsyncIterable / Iterable\n  },\n);\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Client-side"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"// message$ is the stream of messages (AsyncIterable) returned by the server\nconst message$ = terminal.requestService('SubmitOrder', {\n  account_id: 'MyAccountId',\n  // ... other fields omitted\n});\n"})}),"\n",(0,r.jsx)(s.h2,{id:"publishsubscribe-mode",children:"Publish/Subscribe Mode"}),"\n",(0,r.jsx)(s.p,{children:"We use this mode to implement real-time message push."}),"\n",(0,r.jsx)(s.p,{children:"Subscribers subscribe to certain channels, and then publishers need to push messages to subscribers in real time.\nSubscribers and publishers are two Terminals within the same Host.\nThere are many publishers and subscribers within the same Host."}),"\n",(0,r.jsxs)(s.p,{children:["Subscription is a ternary relationship: (",(0,r.jsx)(s.code,{children:"channel_id"}),", ",(0,r.jsx)(s.code,{children:"provider_terminal_id"}),", ",(0,r.jsx)(s.code,{children:"consumer_terminal_id"}),")."]}),"\n",(0,r.jsxs)(s.p,{children:["A channel is identified by a string ",(0,r.jsx)(s.code,{children:"channel_id"}),", whose format is defined by the business layer.\nFor example, ",(0,r.jsx)(s.code,{children:'"AccountInfo/Some-Account-ID"'})," is used to transmit real-time account information."]}),"\n",(0,r.jsx)(s.p,{children:"The core process is:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"Define a channel to identify the channel and its payload message."}),"\n",(0,r.jsx)(s.li,{children:"The publisher should declare in its Terminal information that it provides data for the channel."}),"\n",(0,r.jsx)(s.li,{children:"The subscriber should declare in its Terminal information that it subscribes to the channel from the publisher."}),"\n",(0,r.jsx)(s.li,{children:"The publisher should discover the subscribers and send payload messages to them."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"More detailed rules:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"The subscriber should check if the publisher supports the channel before subscribing."}),"\n",(0,r.jsx)(s.li,{children:"The publisher should collect all subscribers of the channel and send messages to them."}),"\n",(0,r.jsx)(s.li,{children:"The publisher should stop sending messages to the subscriber after the subscriber goes offline."}),"\n",(0,r.jsx)(s.li,{children:"If there are multiple valid candidate publishers, the subscriber should decide which publisher to subscribe to. It is recommended to use a load balancing algorithm to select the publisher."}),"\n",(0,r.jsx)(s.li,{children:"If subscribing to the same channel from multiple publishers, the subscriber should handle conflicts."}),"\n",(0,r.jsx)(s.li,{children:"The publisher should multicast messages to all subscribers by itself."}),"\n",(0,r.jsx)(s.li,{children:"If it is difficult to enumerate all channels, the publisher can define matching patterns to match channels."}),"\n",(0,r.jsx)(s.li,{children:"If the current publisher does not send a message within 60 seconds, the subscriber should switch to another candidate publisher."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"How to use this mode:"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Publisher-side"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"terminal.provideChannel<IAccountInfo>({ const: 'AccountInfo/MyAccountID' }, () => {\n  // Return an RxJS Observable / Promise / AsyncIterable / Iterable\n});\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Subscriber-side"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"const message$ = terminal.consumeChannel<IAccountInfo>('AccountInfo/MyAccountID');\n"})}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"message$"})," is an asynchronous message stream, an AsyncIterable object. You can consume it to receive payload messages."]}),"\n",(0,r.jsxs)(s.li,{children:["The subscriber matches candidate publishers based on the ",(0,r.jsx)(s.code,{children:"channel_id"})," it needs to subscribe to."]}),"\n",(0,r.jsx)(s.li,{children:"The subscriber selects a publisher and declares the subscription. If there are multiple publishers, select one through load balancing."}),"\n",(0,r.jsx)(s.li,{children:"The publisher sends payload messages to the subscriber based on the subscription relationship."}),"\n",(0,r.jsx)(s.li,{children:"When the subscriber unsubscribes, it should promptly delete the subscription declaration."}),"\n",(0,r.jsx)(s.li,{children:"If the current publisher does not send a message within 60 seconds, switch to another candidate publisher."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Defining Matching Patterns"})}),"\n",(0,r.jsx)(s.p,{children:"If it is difficult to enumerate all channels, the publisher can define a matching regular expression string to match channels."}),"\n",(0,r.jsxs)(s.p,{children:["The only difference is that the publisher should declare the matching pattern instead of a constant ",(0,r.jsx)(s.code,{children:"channel_id"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"// JSON Schema\nterminal.provideChannel(\n  {\n    pattern: '^Period/Y/',\n  },\n  (channel_id) => {\n    // Return an RxJS Observable / Promise / AsyncIterable / Iterable\n  },\n);\n"})})]})}function d(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},4317:(e,s,n)=>{n.d(s,{Z:()=>o,a:()=>l});var r=n(3981);const i={},t=r.createContext(i);function l(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);