"use strict";(self.webpackChunk_yuants_docs=self.webpackChunk_yuants_docs||[]).push([[3335],{121:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var s=t(9541),r=t(4317);const i={},o="Protocol",a={id:"reference/protocol",title:"Protocol",description:"Writing is working in progress. The content might be largely changed later.",source:"@site/docs/reference/protocol.md",sourceDirName:"reference",slug:"/reference/protocol",permalink:"/zh-Hans/docs/reference/protocol",draft:!1,unlisted:!1,editUrl:"https://github.com/No-Trade-No-Life/Yuan/tree/main/ui/docs/docs/reference/protocol.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Reference",permalink:"/zh-Hans/docs/category/reference"}},l={},c=[{value:"Message Layer",id:"message-layer",level:2},{value:"Security",id:"security",level:3},{value:"Terminal Info",id:"terminal-info",level:3},{value:"Message Structure",id:"message-structure",level:3},{value:"P2P Direct Connection",id:"p2p-direct-connection",level:3},{value:"Message Pattern Layer",id:"message-pattern-layer",level:2},{value:"Client/Server Pattern (Service Pattern)",id:"clientserver-pattern-service-pattern",level:3},{value:"Provider/Consumer Pattern (Channel Pattern)",id:"providerconsumer-pattern-channel-pattern",level:3},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"protocol",children:"Protocol"}),"\n",(0,s.jsx)(n.admonition,{title:"Working In Progress",type:"warning",children:(0,s.jsx)(n.p,{children:"Writing is working in progress. The content might be largely changed later."})}),"\n",(0,s.jsxs)(n.admonition,{title:"Technical Reference",type:"info",children:[(0,s.jsx)(n.p,{children:"This is a technical reference for the protocol used by the system. It is intended for developers and system administrators."}),(0,s.jsxs)(n.p,{children:["Our official npm package ",(0,s.jsx)(n.code,{children:"@yuants/protocol"})," have implemented the protocol. You can use it directly."]})]}),"\n",(0,s.jsx)(n.p,{children:"We define a protocol as a set of rules that govern the exchange of messages between two or more parties. The protocol is the foundation of the system and is responsible for the following:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Layer"}),(0,s.jsx)(n.th,{children:"Participants"}),(0,s.jsx)(n.th,{children:"Responsibility"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Transport Layer"}),(0,s.jsx)(n.td,{children:"TCP Sockets"}),(0,s.jsx)(n.td,{children:"Reliable delivery of messages"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["Message Layer",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),(0,s.jsx)(n.td,{children:"Host, Terminal"}),(0,s.jsx)(n.td,{children:"Networking and routing, basic secure boundary"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Message Pattern Layer"}),(0,s.jsx)(n.td,{children:"Client/Server, Provider/Consumer"}),(0,s.jsx)(n.td,{children:"Load balance, candidate election"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Business Layer"}),(0,s.jsx)(n.td,{children:"Specified by method"}),(0,s.jsx)(n.td,{children:"Specified by method"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"message-layer",children:"Message Layer"}),"\n",(0,s.jsx)(n.p,{children:"Host is a WebSocket server that listens for incoming connections from terminals. Terminals are WebSocket clients that connect to the host."}),"\n",(0,s.jsx)(n.p,{children:"Host can usually be access by Internet and Terminals are usually located in a local network and are not accessible from the Internet.\nSo terminals can connect to the host and transmit messages to each other through the host. Terminals are peers and can be considered as a P2P network."}),"\n",(0,s.jsx)(n.p,{children:"Host is dumb component and only forwards messages between terminals. While terminals are smart components and can process messages."}),"\n",(0,s.jsx)(n.h3,{id:"security",children:"Security"}),"\n",(0,s.jsx)(n.p,{children:"Host usually can be accessed from Internet. It's recommend to deploy a TLS certificate to encrypt the communication between terminals and host. We have done this in our official artifacts."}),"\n",(0,s.jsx)(n.p,{children:"And Host has a basic token authentication mechanism to prevent unauthorized access from Internet. When terminal connects to the host, it needs to provide a token. The token is a string that is pre-defined when the host deployed."}),"\n",(0,s.jsx)(n.p,{children:"Terminal need to provide the host_token in the query string of the URL when connecting to the host. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"wss://api.ntnl.io/hosts?host_id=amazing_host&host_token=very_long_token&terminal_id=your_terminal_id\n"})}),"\n",(0,s.jsx)(n.p,{children:"There's always trade-off between security and efficiency.\nWe choose to sacrifice inside-host security for efficiency.\nBecause efficiency is directly related to machine cost.\nHigher efficiency means save your money."}),"\n",(0,s.jsx)(n.p,{children:"Host is the secure boundary of the system. Assume that the host is secure and trusted.\nTerminal will default trust other terminals in the host and will not verify the identity."}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"Never leak the host token to the others. Everyone who knows the host token can connect to the host and send messages to terminals.\nIt may cause serious security problems and loss your money and secrets."})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsx)(n.p,{children:"A terminal process can connect to multiple hosts at the same time. It's useful when you want to share data with partner.\nHost is very lightweight and you can deploy a shared host for your sharing purpose."}),(0,s.jsx)(n.mermaid,{value:"graph LR\n    A[Your Personal Host] <--\x3e B[Your Terminal]\n    B <--\x3e C[Shared Host]\n    C <--\x3e D[Partner's Terminal]\n    D <--\x3e E[Partner's Personal Host]"})]}),"\n",(0,s.jsx)(n.h3,{id:"terminal-info",children:"Terminal Info"}),"\n",(0,s.jsx)(n.p,{children:"Terminal should declare its terminal info when connecting to the host. Terminal info is a JSON object:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export interface ITerminalInfo {\n  terminal_id: string;\n  // others is ellipsis\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"terminal_id is the unique ID of the terminal. It should be unique in the host."}),"\n",(0,s.jsx)(n.li,{children:"Terminal Info usually contains the service information of the terminal. For example, the terminal can declare that it provides the service of account information."}),"\n",(0,s.jsx)(n.li,{children:"Terminal Info is used for message pattern layer, we will introduce it later."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"message-structure",children:"Message Structure"}),"\n",(0,s.jsx)(n.p,{children:"All messages are JSON encoded and have the following structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export interface ITerminalMessage {\n  source_terminal_id: string;\n  target_terminal_id: string;\n\n  // other fields are used for message pattern layer, introduce later.\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"source_terminal_id is the terminal ID of the sender."}),"\n",(0,s.jsx)(n.li,{children:"target_terminal_id is the terminal ID of the receiver."}),"\n",(0,s.jsx)(n.li,{children:"Host will read the target_terminal_id and forward the message to the target terminal."}),"\n",(0,s.jsx)(n.li,{children:"Other fields are used for message pattern layer, we will introduce it later."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"p2p-direct-connection",children:"P2P Direct Connection"}),"\n",(0,s.jsx)(n.p,{children:"We can use WebRTC to establish a P2P connection between 2 terminals. WebRTC is a peer-to-peer technology that allows terminals to directly exchange message. It's a perfect choice for our purpose. No need to transfer messages through the host. It's faster and less traffic cost. When a P2P connection is established, the host will stop forwarding messages between the 2 terminals. Actually, the terminal will not send messages to the host anymore. The behavior of the host never changed. However, if the P2P connection is broken, the host will resume forwarding messages between the 2 terminals."}),"\n",(0,s.jsx)(n.p,{children:"Host will also forward the ICE candidates (offers and answers) between the 2 terminals. So the 2 terminals can establish a P2P connection. Host is both STUN server and TURN in-role."}),"\n",(0,s.jsx)(n.p,{children:"The peer connection is established implicitly. When a terminal sends a message to another terminal, the terminal will check if there's a P2P connection with the target terminal. If not, the terminal will try to establish a P2P connection with the target terminal. If the P2P connection is established, the terminal will send message through the peer connection. If the P2P connection is broken, the terminal will resume sending messages through the host."}),"\n",(0,s.jsx)(n.h2,{id:"message-pattern-layer",children:"Message Pattern Layer"}),"\n",(0,s.jsx)(n.p,{children:"There're 2 types of message pattern: Client/Server and Provider/Consumer."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Client sends request to Server and Server sends response to client."}),"\n",(0,s.jsx)(n.li,{children:"Provider push messages to Consumer."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"clientserver-pattern-service-pattern",children:"Client/Server Pattern (Service Pattern)"}),"\n",(0,s.jsx)(n.p,{children:"We use this pattern to implement request/response service."}),"\n",(0,s.jsx)(n.p,{children:"Client sends request to server and server sends response to client.\nThe client and the server are 2 terminals in the same host.\nThe request and response are terminal messages."}),"\n",(0,s.jsx)(n.p,{children:"Service is identified by the method name."}),"\n",(0,s.jsx)(n.p,{children:"The core procedure is:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Define a method to identify the request and response format and behavior."}),"\n",(0,s.jsx)(n.li,{children:"The server should declare in its terminal info that it provides the service."}),"\n",(0,s.jsx)(n.li,{children:"The client should discover the server and send request to the server."}),"\n",(0,s.jsx)(n.li,{children:"The server should process the request and send response to the client."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"And more detail rules:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Server can send multiple messages before sending response."}),"\n",(0,s.jsx)(n.li,{children:"Session is the process from request to response, which is identified by the trace_id field in the message."}),"\n",(0,s.jsx)(n.li,{children:"Server should declare the methods it supports. Discriminators are the method name and JSON Schema."}),"\n",(0,s.jsx)(n.li,{children:"Client should check if the Server supports the method and validate the request by the JSON Schema before sending request."}),"\n",(0,s.jsx)(n.li,{children:"Client should select a Server to send request if there're multiple valid candidates. It's recommended to use load balance algorithm to select a Server."}),"\n",(0,s.jsx)(n.li,{children:"Server should send first message in 30 seconds after receiving request. If Server doesn't send response in 30 seconds, Client should throw an timeout error."}),"\n",(0,s.jsx)(n.li,{children:"Server should never send messages to Client after sending response. If any, Client should ignore them."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"How to use this pattern:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Server side"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"terminal.provideService(\n  'SubmitOrder',\n  {\n    type: 'object',\n    properties: {\n      account_id: { const: 'MyAccountId' },\n    },\n  },\n  (msg) => {\n    // return a RxJS observable of terminal messages\n  },\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Client side"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// message$ is a RxJS Observable returned by the server\nconst message$ = terminal.requestService('SubmitOrder', {\n  account_id: 'MyAccountId',\n  // ... other fields are ellipsis\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"providerconsumer-pattern-channel-pattern",children:"Provider/Consumer Pattern (Channel Pattern)"}),"\n",(0,s.jsx)(n.p,{children:"We use this pattern to implement real-time message push."}),"\n",(0,s.jsx)(n.p,{children:"Consumer subscribes some channel, and then the provider need to push messages to the consumer in real-time.\nThe consumer and the provider are 2 terminals in the same host.\nAnd there're many providers and consumers in the same host."}),"\n",(0,s.jsx)(n.p,{children:"Subscription is a 3-ary relation: (channel_id, provider_terminal_id, consumer_terminal_id)."}),"\n",(0,s.jsxs)(n.p,{children:["Channel is identified by the channel_id, its format is defined by business layer.\nFor example, channel_id ",(0,s.jsx)(n.code,{children:"encodePath('AccountInfo', account_id)"})," is used to transmit real-time account information.\nIt's recommended to use ",(0,s.jsx)(n.code,{children:"encodePath"})," to generate channel_id, and ",(0,s.jsx)(n.code,{children:"decodePath"})," to parse channel_id. Because it's easy and human-readable.\nHowever, you can use any format you like. It's not the concern of message pattern layer."]}),"\n",(0,s.jsx)(n.p,{children:"The core procedure is:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Define a channel to identify the channel and its payload messages."}),"\n",(0,s.jsx)(n.li,{children:"The provider should declare in its terminal info that it provides the data of the channel."}),"\n",(0,s.jsx)(n.li,{children:"The consumer should declare in its terminal info that it subscribes channel from the provider."}),"\n",(0,s.jsx)(n.li,{children:"The provider should discover the consumer and send payload messages to the consumer."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"And more detail rules:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The consumer should check if the provider supports the channel before subscribing."}),"\n",(0,s.jsx)(n.li,{children:"The provider should collect all consumers that subscribe the channel and send messages to them."}),"\n",(0,s.jsx)(n.li,{children:"The provider should stop sending messages to the consumer after the consumer is offline."}),"\n",(0,s.jsx)(n.li,{children:"The consumer should decide which provider to subscribe if there're multiple valid candidates. It's recommended to use load balance algorithm to select a provider."}),"\n",(0,s.jsx)(n.li,{children:"The consumer should handle the conflict if it subscribe the same channel from multiple providers."}),"\n",(0,s.jsx)(n.li,{children:"The provider should multicast messages to all consumers by itself."}),"\n",(0,s.jsx)(n.li,{children:"The provider might define a matching pattern to match the channel if it's hard to enumerate all channels."}),"\n",(0,s.jsx)(n.li,{children:"The consumer should switch to another candidate provider if the current provider doesn't send messages in 60 seconds."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"How to use this pattern:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Provider side"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"terminal.provideChannel<IAccountInfo>({ const: 'AccountInfo/MyAccountID' }, () => {\n  // return a RxJS Observable of payload messages\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Consumer side"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// message$ is a RxJS Subject returned by the provider\nconst message$ = terminal.consumeChannel<IAccountInfo>('AccountInfo/MyAccountID');\n"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"message$ is a RxJS Subject. You can subscribe it to receive payload messages."}),"\n",(0,s.jsx)(n.li,{children:"match the channel_id and find the candidate providers."}),"\n",(0,s.jsx)(n.li,{children:"select one provider and declare the subscription."}),"\n",(0,s.jsx)(n.li,{children:"receive payload messages from the provider."}),"\n",(0,s.jsx)(n.li,{children:"unsubscribe the channel if message$ is unsubscribed."}),"\n",(0,s.jsx)(n.li,{children:"switch to another candidate provider if the current provider doesn't send messages in 60 seconds"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Define a matching pattern"})}),"\n",(0,s.jsx)(n.p,{children:"The provider might define a matching regexp string to match the channel if it's hard to enumerate all channels."}),"\n",(0,s.jsx)(n.p,{children:"The only difference is that the provider should declare the matching pattern instead of the constant channel_id."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// JSON Schema\nterminal.provideChannel(\n  {\n    pattern: '^Period/Y/.+/.+$',\n  },\n  (channel_id) => {\n    // return a RxJS Observable by channel_id\n  },\n);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.p,{children:["You can read the source code of our official npm package ",(0,s.jsx)(n.code,{children:"@yuants/protocol"})," to learn more about the protocol."]}),"\n",(0,s.jsx)(n.p,{children:"You can read the business layer (TODO) specification to learn more about the business."}),"\n",(0,s.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,s.jsxs)(n.p,{children:["Yes, we are reinventing the network layer of the Internet. We have to do this because we need to support peer connection between terminals. In traditional network model, browser can actively connect to server but cannot be passively serve others. Host seems to have built a virtual private network. But building a virtual private network is hard and risky in practice. ",(0,s.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},4317:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var s=t(3981);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);